<HTML>
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<TITLE>Удаленные репозитории</TITLE>
<meta name="KeyWords" content="git">
</HEAD>
<BODY BGCOLOR="#DDE1C2" TEXT="#002040">

<div style="width:85%;  margin: auto;">

<h3>Удаленные репозитории</h3>

<p>
Git позволяет работая в одном репозитории получать и принимать изменения из другого репозитория.
В этом случае первый репозиторий называется <i>локальным</i>, а второй - <i>удаленным</i>.
</p>
<p>
Удаленный репозиторий может располагаться на том же компьютере, что и локальный, в локальной сети, или где то в интернете. Главное у пользователя должен быть доступ к нему одним из способов, который поддерживает <i>git</i>.
Для получения изменений достаточно иметь доступ на чтение, для передачи изменений нужен доступ на запись.
</p><p>
Для того, чтобы находясь в локальном репозитории иметь возможность работать с удаленным репозиторием, надо <i>подсоединить</i> удаленный репозиторий к локальному, т.е. присвоить удалённому репозиторию имя (shortname) и указать его URL.
Подсоединение выполняется командой <i>git remote add &lt;shortname&gt; &lt;url&gt;</i>.
Эта команда сохраняет имя и URL удаленного репозитория в локальном конфигурационном файле.
</p><p>
Командой <i>git remote</i> без параметров можно посмотреть список всех подсоединенных удаленных репозиториев.
Эта же команда с параметром «-v» выводит дополнительно URL удаленных репозиториев.
URL для чтения (fetch) и записи (push), в общем случае, может отличаться.
Но даже если они совпадают, команда выводит две строки на каждый удаленный репозиторий.
(В результате какой команды могут получиться разные URL для чтения и записи???????????????).
</p><p>
Пусть у нас имеется репозиторий в текущей папке и репозиторий по пути <i>/home/Thomas/project1</i>, с которым мы хотим работать как с удаленным репозиторием.
<pre><code><font>
$ git remote add origin /home/Thomas/project1

$ git remote
origin

$ git remote -v
origin	/home/Thomas/project1 (fetch)
origin	/home/Thomas/project1 (push)
</font></code></pre>
</p>

****************************

<h3>Работа с удаленными репозиториями по сети</h3>

****************************

<h3>Голые репозитори</h3>

<p>
Репозитории бывают двух видов: обычные (которые мы рассматривали до сих пор) и голые (bare).
Голые репозитории не имеют рабочего каталога; они используются только в качестве удаленных.
Обычные репозитории тоже можно использовать в качестве удаленных, но их можно только читать, писать в них нельзя! ??????????????
</p><p>
Голые репозитории создаются командой <i>git init</i> с параметром <i>--bare</i>.
<pre><code><font>
$ git init --bare test.git
</font></code></pre>
</p>

****************************

<h3>Создание клонов репозитория. Команда <i>git clone</i></h3>

<p>
Новый репозиторий можно создать на основе существующего командой <i>git clone</i>.
При клонировании репозитория происходит подсоединение клонированного репозитория как удаленного, с именем «origin».
При клонировании копируется текущая ветка (указатель текущей ветки) и она становится текущей веткой нового репозитория (обычно это ветка <i>master</i>).
Эта ветка настраивается как отслеживающая (см. долее) соответствующую удаленную ветку. ????
</p><p>
<pre><code><font>
$ git clone /home/Thomas/project1 pr1_c

$ cd pr1_c

$ git remote
origin

$ git remote -v
origin	/home/Thomas/project1 (fetch)
origin	/home/Thomas/project1 (push)
</font></code></pre>
</p>

****************************

<h3>Получение изменений из удаленного репозитория.<br>Удалённые указатели и удалённые ветки.<br>Команда <i>git fetch</i></h3>

<p>
Команда <i>git fetch</i> загрузит с сервера все изменения, которых у вас еще нет.
<br>
Все новые объекты загружаются в локальную базу объектов <i>.git\objects</i>, а новые указатели удаленного репозитория в каталог <i>.git\refs\remotes\&lt;имя_удаленного_репозитория&gt;</i>)
<br>
Эта команда не меняет содержимого вашего рабочего каталога.
</p><p>
Файлы каталога <i>.git\refs\remotes\&lt;имя_удаленного_репозитория&gt;</i>, являются копиями указателей удаленного репозитория и называются <i>удаленными указателями</i>.
Если локальные указатели двигаются когда мы делаем коммиты в локальном репозитории, то удаленные указатели двигаются, когда мы получаем изменения из удаленного репозитория.
</p><p>
В каталоге <i>.git\refs\remotes\&lt;имя_удаленного_репозитория&gt;</i> помимо копий указателей удаленного репозитория хранится копия файла <i>.git\HEAD</i> ????????????
</p><p>
Обращения к указателям (веткам) удаленного репозитория выглядят так: <i>&lt;имя_удаленного_репозитория&gt;/&lt;имя_указателя/ветки&gt;</i>.
Например, если вы хотите посмотреть, как выглядела ветка <i>master</i> на сервере <i>origin</i> во время последнего соединения с ним, проверьте ветку <i>origin/master</i>.
Если вы с партнёром работали над одной проблемой, и он выложил ветку <i>iss53</i>, у вас может быть своя локальная ветка <i>iss53</i>; но та ветка на сервере будет указывать на коммит в <i>origin/iss53</i>.
</p><p>
После получения изменений из удаленного репозитория можно выполнить слияние командой <i>git merge</i>.
Только она изменит файла вашего рабочего каталога.
</p>

<p>
Допустим для получения обновлений из удаленного репозитория <i>origin</i> вы выполнили команду:
<pre><code>$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -&gt; origin/serverfix</code></pre>

Из удаленного репозитория мы получили 7 новых объектов и новый указатель <i>serverfix</i>, как удалённый указатель <i>origin/serverfix</i>.
Однако локальный указатель/ветка <i>serverfix</i> создан не будет!
</p><p>
Все удаленные указатели можно посмотреть командой <i>git branch</i> с опцией <i>-r</i>
<pre><code>$ git branch -r
  origin/master
  origin/serverfix</code></pre>
</p><p>
Переключится на удаленную ветку можно так
<pre><code>$ git checkout origin/serverfix</code></pre>
</p><p>
Вы можите слить удаленную ветку со своей текущей веткой, выполнив
<pre><code>git merge origin/serverfix</code></pre>
</p><p>
Вы можите создать свою локальную ветку <i>serverfix</i> на основе удалённой ветки и продолжить работать в ней.
Создадим ветку, на основе удаленной и перейдем на неё:
<pre><code>$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</code></pre>
Созданная ветка <i>serverfix</i> будет начинаться там же, где <i>origin/serverfix</i>.
</p>

<h3>Команда <i>git pull</i>. Отслеживание веток</h3>

<p>
Существует команда <i>git pull</i>, которая является по существу командой <i>git fetch</i>, непосредственно за которой следует команда <i>git merge</i>.
Если у вас есть отслеживаемая ветка, то <i>git pull</i> увидит, что сервер и ветка вашей текущей ветки отслеживается, извлечет с сервера и затем попытается объединить в удаленную ветку.
Однако обычно лучше просто явно использовать команды <i>git fetch</i> и <i>git merge</i>, поскольку магия <i>git pull</i> может часто сбивать с толку.
</p><p>
Отслеживаемые ветки (upstream branch) — это локальные ветки, которые напрямую связаны с удалённой веткой.
Если, находясь на отслеживаемой ветке, вы наберёте <i>git pull</i>, Git уже будет знать, с какого сервера получить все удалённые ссылки и сделает слияние с соответствующей удалённой веткой.
Аналогично выполнение <i>git pull</i> на одной из таких веток, сначала получает все удалённые ссылки, а затем автоматически делает слияние с соответствующей удалённой веткой.
</p><p>
Отслеживаемая ветка устанавливается командой <i>git branch</i> с ключом <i>-u</i> или <i>--set-upstream-to</i>.
<br>
Если вы хотите, чтобы локальная ветка <i>&lt;ветка1&gt;</i> отслеживала удаленную ветку <i>&lt;удалённый_репозиторирий&gt;/&lt;ветка2&gt;</i>, то вы можете воспользоваться командой <i>git branch -u &lt;удалённый_репозиторирий&gt;/&lt;ветка2&gt; &lt;ветка1&gt;</i>.
<br>
Ветку &lt;ветка1&gt; можно не указывать.
Если &lt;ветка1&gt; не указана, то подразумевается текущая ветка.
<pre><code>$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.</code></pre>
Этой же командой можно переназначить отслеживаемую метку.
</p><p>
Создать ветку на основе удаленной ветке и переключиться на неё, можно командой <i>git checkout --track &lt;удалённый_репозиторирий&gt;/&lt;ветка&gt;</i>.
<br>
Эта команда создает локальную ветку с именем как у удаленной метки.
<br>
Эта созданная ветка, назначается отслеживающей ту удаленную ветку на основе которой она была создана.
<pre><code>$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</code></pre>
</p><p>
Команда <i>git checkout -b &lt;ветка1&gt; &lt;удалённый_репозиторирий&gt;/&lt;ветка2&gt;</i> создает ветку с именем, отличным от имени удалённой ветки:
<pre><code>$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'</code></pre>
</p><p>
Теперь ваша локальная ветка <i>sf</i> будет отслеживать ветку <i>origin/serverfix</i>.
</p><p>
Если вы хотите посмотреть какие отслеживаемые ветки у вас установлены, вы можете воспользоваться опцией <i>-vv</i> в команде <i>git branch</i>. Отобразится список ваших локальных веток с дополнительной информацией, включая то, какая из веток отслеживается, и если локальная ветка опережает, отстает или равняется относительно основной ветки.</p>

<pre><code>$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new</code></pre>

<p>Итак, здесь мы можем видеть, что наша <i>iss53</i>-ветка отслеживает <i>origin/iss53</i> и она опережает на два изменения, означающее, что мы имеем два локальных коммита, которые не отправлены на сервер. Мы может также увидеть, что наша <i>master</i>-ветка отслеживает <i>origin/master</i> и она в актуальном состоянии. Далее мы можем видеть, что наша <i>serverfix</i>-ветка отслеживает <i>server-fix-good</i>-ветку на нашем <i>teamone</i>-сервере и опережает на три коммита и отстает на один, означающее, что есть один коммит на сервере, который мы еще не слили и три локальных коммита, которые вы еще не отправили. В конце мы видим, что наша <i>testing</i>-ветка не отслеживает удаленную ветку.
</p><p>
Важно отметить, что эти цифры — только с каждого сервера, которые последний раз были извлечены. Эта команда не обращается к серверам, она говорит вам о том, что в кэше есть локальная информация с серверов. Если вы хотите полностью быть в курсе опережающих и отстающих коммитов, вам необходимо извлечь данные из всех ваших удаленных серверов перед запуском этой команды. Вы можете сделать нечто подобное: <i>$ git fetch --all; git branch -vv</i>
</p><p>
Если имеется отслеживаемая ветка <i>удаленный_репозиторий/ветка</i> соответствующая локальной ветке <i>ветка</i> и <i>ветка</i> является текущей веткой, в команде <i>git</i> ссылаться на отслеживаемую ветку можно с помощью конструкции <i>@{upstream}</i> или, что тоже самое <i>@{u}</i>.
<br>Так, если вы находитесь на <i>master</i>-ветке, а отслеживается <i>origin/master</i>, то вместо <i>git merge origin/master</i> вы можите написать <i>git merge @{u}</i>.
</p>

<h3>Отправка изменений. Команда <i>git push</i></h3>

<p>
Когда вы хотите поделиться веткой с окружающими, вам необходимо отправить (push) её на удалённый сервер, на котором у вас есть права на запись.
Не все ваши локальные ветки будут синхронизируются с удалёнными репозиториями.
Вам нужно явно указать те ветки, которыми вы хотите поделиться.
Так вы можете отправлять только те тематические ветки, над которыми вы работаете с кем-то совместно,
и не отправлять свои личные ветки для работы, которую вы не хотите показывать.
</p>

<p>
Если у вас есть ветка <i>serverfix</i>, над которой вы хотите работать с кем-то ещё, вы можете отправить её точно так же, как вы отправляли вашу первую ветку.
<br>
Выполните <i>git push &lt;имя_удаленного_репозитория&gt; &lt;имя_ветки&gt;</i>:
</p>

<pre><code>$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -&gt; serverfix</code></pre>

<p>
Это в некотором роде сокращение.
Git автоматически разворачивает имя ветки <i>serverfix</i> до <i>refs/heads/serverfix:refs/heads/serverfix</i>, что означает “возьми мою локальную ветку serverfix и обнови ей удалённую ветку serverfix.”
Вы также можете выполнить <i>git push origin serverfix:serverfix</i> — произойдёт то же самое — здесь говорится “возьми мой serverfix и сделай его удалённым serverfix.”
Можно использовать этот формат для отправки локальной ветки в удалённую ветку с другим именем.
Если вы не хотите, чтобы ветка называлась <i>serverfix</i> на удалённом сервере, то вместо предыдущей команды выполните <i>git push origin serverfix:awesomebranch</i>.
Так ваша локальная ветка <i>serverfix</i> отправится в ветку <i>awesomebranch</i> удалённого проекта.
</p>

<h3>Удаление веток на удалённом сервере</h3>

<p>
Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку <i>master</i> на удалённом сервере (или в какую-то другую ветку, где хранится стабильный код).
Вы можете удалить ветку на удалённом сервере, используя опцию <i>--delete</i> для <i>git push</i>.
Если вы хотите удалить ветку <i>serverfix</i> на сервере, выполните следующее:</p>

<pre><code>$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix</code></pre>

<p>В основном всё, что делает эта строка, — удаляет указатель на сервере. Как правило, Git-сервер оставит данные на некоторое время, пока не запустится сборщик мусора. Итак, если ветка случайно была удалена, чаще всего ее легко восстановить.</p>

</div>
</BODY></HTML>
