<HTML lang="ru">
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<TITLE>Git не для чайников</TITLE>
<meta name="KeyWords" content="git">
</HEAD>
<BODY>

<div style="width:85%;  margin: auto;">

<p><a href="http://htmlpreview.github.io/?https://github.com/konstant-in/doc1/blob/master/Git.html">оригинал</a></p>

<h1>Git не для чайников</h1>

<h4>Для пользователей, которые не только хотят уметь с работать git, но и понимать как он устроен</h4>

<p>
Git это программный продукт относящийся к классу <i>систем контроля версий (СКВ, VCS)</i>.
Чтобы программный продукт можно было отнести к этому классу, он, как минимум, должен:
<br>
1) уметь вести истории изменений файлов в заданном каталоге, храня старые версии файлов и информацию о том кто и когда эти изменения выполнил и 
<br>
2) позволять восстанавливать, при необходимости, старых версий файлов.
</p><p>
Git прекрасно с этим справляется и умеет делать другие вещи.
</p><p>
Git не имеет графического пользовательского интерфейса, т.к. является пакетом консольных утилит (утилит работающих в командной строке). Вся функциональность Git реализована через утилиты командной сроки.
Поэтому от читателей требуются элементарные навыки работы с командной строкой в unix-подобных операционных системах.
</p><p>
Каталог, файлы которого git отслеживает, будем называть <i>рабочим каталогом</i>.
В рабочем каталоге, git создает служебный каталог <i>.git</i>, который будем называть <i>репозиторием</i>.
</p><p>
Git это очень гибкая СКВ. Она позволяющая строить разные стратегии работы над проектами.
</p><p>
С git может работает один человек. Рабочий каталог и репозиторий располагается на его компьютере.
</p><p>
Возможна схема, когда над одним проектом работают несколько человек и при этом каждый их этих пользователей работает со своим рабочим каталогом и репозиторием, расположенными у каждого на его компьютере.
Время от времени репозитории каждого пользователя обмениваются между собой информацией.
Связь между репозиториями требуется только во время обмена информацией.
В остальное время можно работать совершенно автономно.
</p><p>
Git позволяет организовать централизованную систему с центральным репозиторием в локальной сети или в интернете.
При этом каждый пользователей по прежнему работает со своим рабочим каталогом и репозиторием, расположенными у каждого на его компьютере и время от времени обмениваются информацией с центральным репозиторием.
Как и в первом случае связь между репозиториями требуется только во время обмена информацией.
</p>

<h3>Минимальная настройки git после инсталляции</h3>

<p>
После установки Git, настройте глобальный конфигурационный файл.
Для начала работы можно ограничится только указанием вашего имени, фамилии и адреса электронной почты.
<pre><code style="color: blue">
$ git config --global user.name "Ваши имя и фамилия в кавычках"
$ git config --global user.email "Ваш адрес электронной почты в кавычках"
</code></pre>
Например:
<pre><code style="color: blue">
$ git config --global user.name "Alex Petrov"
$ git config --global user.email "alex@localhost"
</code></pre>
Если вы не выбрали редактор при инсталляции системы, можно выбрать это сейчас.
Не оставляете в качестве редактора vim, если вы с ним никогда не работали.
Если вы его видите первый раз, то работать с ним, и даже выйти из него, у вас не получится.
<pre><code style="color: blue">
$ git config ...
</code></pre>
Для просмотра всех настроек глобального файла конфигурации выполните:
<pre><code style="color: blue">
$ git config --global --list
...
</code></pre>
для просмотра конкретного параметра -
<pre><code style="color: blue">
$ git config --global user.name
Ivan Ivanov
</code></pre>

    <h3>Создание нового репозитария</h3>

<p>
Любой каталог можно превратить в <i>рабочий каталог Git (work tree)</i> выполнив в нем команду инициализации репозитория.
Команда инициализации создает внутри него репозиторий - подкаталог <i>.git/</i> внутри которого будет хранится вся история этого репозитория.
</p><p>
Git хранит историю не всех файлов рабочего каталога.
Чтобы начать хранить историю версий какого-либо файла надо отдать его под версионный контроль.
Файлы отданные под версионный контроль называются <i>отслеживаемыми</i>.
</p><p>
Создадим у себя на компьютере пустую папку и инициализируем в ней репозиторий.<br>
Репозиторий инициализируется командой <i>git init</i>.</p>
<pre><code style="color: blue">
$ mkdir ~/project1
   
$ cd ~/project1
   
$ git init
Initialized empty Git repository in .git/
</code></pre>
Новый репозиторий создан.
    <p>
В разных проектах с разными репозиториями можно работать под разными именами.
С этим репозитарием мы будем работать под именем Ivan Ivanov &lt;ivan@localhost&gt;.
<pre><code style="color: blue">
$ git config user.name "Ivan Ivanov"
$ git config user.email "ivan@localhost"
</code></pre>
Команда <i>git config</i> без параметра <i>--global</i> заносит имя, фамилию и почту в локальный конфигурационный файл,
    относящийся только к этому репозиторию.

    <h3>Состояние репозитория. Команда <i>git status</i></h3>

<p>
Посмотреть состояние репозитория можно командой <i>git status</i>
<pre><code style="color: blue">
$ git status
On branch master

No commits yet

nothing to commit (create/copy files and use "git add" to track)
</code></pre>
Добавим в каталог репозитория два файла
<pre><code style="color: blue">
$ mkdir d

$ echo -n "File1 v1" > file1

$ echo -n "File2 v1" > d/file2

$ git status
On branch master

No commits yet

Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

        d/
        file1

nothing added to commit but untracked files present (use "git add" to track)
</code></pre>
Команда <i>git status</i> сообщает нам, что у нас появились два неотслеживаемых файла

    <h3>Как сделать файл отслеживаемым? Команда <i>git add</i></h3>

<p>
Чтобы отдать файл или группу файлов под версионный контроль, т.е. сделать их отслеживаемыми, надо выполнить команду <i>git add</i>, передав ей в качестве параметров эти файлы.
<pre><code style="color: blue">
$ git add .

$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached &lt;file&gt;..." to unstage)

        new file:   d/file2
        new file:   file1
</code></pre>
    С этого момента эти файла стали отслеживаемыми.
    Теперь мы можем зафиксировать новое состояние репозитория.

    <h3>Фиксация состояний репозитория. Команда <i>git commit</i></h3>

<p>
Все состояния репозитория которые мы хотим иметь возможность восстановить в будущем подлежат <i>фиксации</i>.
Фиксация выполняется одноименной командой <i>git commit</i>.
</p><p>
Зафиксируем состояние нашего репозитория, но перед этим установим значение двух переменных окружения GIT_AUTHOR_DATE и GIT_COMMITTER_DATE. В учебных примерах мы это будем делать всякий раз, перед выполнением операции <i>git commit</i>.
Это необходимо, чтобы идентификаторы commit и tree объектов, создаваемые командой <i>git commit</i> и зависящие от времени, у всех, кто будет повторять эти примеры, были такими же как у меня. Об объектах и их идентификаторах немного делее.
<br>
В реальной работе этого разумеется делать не надо. Команда <i>git commit</i> будет использовать текущие дату и время.
<pre><code style="color: blue">
$ export GIT_AUTHOR_DATE="2000-01-01 00:01"

$ export GIT_COMMITTER_DATE="2000-01-01 00:01"

$ git commit -m "comment #1"
[master (root-commit) 69701b6] comment #1
 2 files changed, 2 insertions(+)
 create mode 100644 d/file2
 create mode 100644 file1
</code></pre>
Примечание: Если вместо числа 69701b6, в выводе команды, вы видите другое число, то это значит, что вы неправильно установили переменные окружения, о которых только что говорилось, либо установили не то имя или почтовый адрес (не Ivan Ivanov &lt;ivan@localhost&gt;).
    <p>
Посмотрим что выдает команды <i>git log</i>.
<pre><code style="color: blue">
$ git log
commit 69701b6e701d429882c083e98e1ecf195868b38c (HEAD -> master)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1
</code></pre>
    Из вывода команды видно кто и когда зафиксировал новое состояние, и какое сообщение (комментарий) оставил для тех,
    кто позднее будет разбираться с историей репозитория.
    В реальной работе надо конечно оставлять более информативные сообщения.
    <p>
Посмотрим что выдает команда<i>git status</i>.
<pre><code style="color: blue">
$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
Снова видим что «фиксировать нечего (nothing to commit)»
и что «рабочий каталог чист (working tree clean)»
    <p>
Создадим в рабочем каталоге еще один файл
<pre><code style="color: blue">
$ echo -n "File3 v1" > file3

$ git status
On branch master
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

        file3

nothing added to commit but untracked files present (use "git add" to track)
</code></pre>
    <p>
Под заголовком «Untracked files:» команда вывела добавленный нами файл file3. Он пока неотслеживаемый. Если попробовать зафиксировать новое состояние репозитория, то ничего не произойдет.
<pre><code style="color: blue">
$ git commit -m "comment #2"
On branch master
Untracked files:
        file3

nothing added to commit but untracked files present
</code></pre>
    <p>
Сделаем файл file3 отслеживаемым и посмотрим на новый статус репозитория
<pre><code style="color: blue">
$ git add file3

$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        new file:   file3
</code></pre>
Команда вывела файл file3 уже под заголовком «Changes to be committed:». Сейчас файл file3 подготовлен (stage) для фиксации.
    <p>
Выполним фиксацию и снова посмотрим статус
<pre><code style="color: blue">
$ export GIT_AUTHOR_DATE="2000-01-01 00:02"

$ export GIT_COMMITTER_DATE="2000-01-01 00:02"

$ git commit -m "comment #2"
[master 03c1a7f] comment #2
 1 file changed, 1 insertion(+)
 create mode 100644 file3

$ git log
commit 03c1a7f12800978dde0b8cd6383595e7007d0098 (HEAD -> master)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:02:00 2000 +0200

    comment #2

commit 69701b6e701d429882c083e98e1ecf195868b38c
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1

$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
    У нас «чистый» репозиторий с двумя зафиксированными изменениями.
    <p>
<p>
Изменим содержимое файла file3, добавив еще одну строку. И смотрим статус.
<pre><code style="color: blue">
$ echo -ne "\nSecond line (v2)" >> file1

$ git status
On branch master
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   file1

no changes added to commit (use "git add" and/or "git commit -a")
</code></pre>
Файл file1 выведен уже под заголовком «Changes not staged for commit:». Он модифицирован (Modified). Модифицированные файла, как и новые, перед фиксацией тоже надо подготовить.
    <p>
Подготовим для фиксации новую версию файла file1.
<pre><code style="color: blue">
$ git add file1

$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        modified:   file1
</code></pre>
Замечание: Команда git add не только добавляет под версионный контроль новые файлы, но и помечаются измененные файлы, которые готовы для фиксации.
<br>
Подготовка выполнена. Можно фиксировать новое состояние.
<pre><code style="color: blue">
$ export GIT_AUTHOR_DATE="2000-01-01 00:03"

$ export GIT_COMMITTER_DATE="2000-01-01 00:03"

$ git commit -m "comment #3"
[master 344b36b] comment #3
 1 file changed, 2 insertions(+), 1 deletion(-)

$ git log
commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (HEAD -> master)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:03:00 2000 +0200

    comment #3

commit 03c1a7f12800978dde0b8cd6383595e7007d0098
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:02:00 2000 +0200

    comment #2

commit 69701b6e701d429882c083e98e1ecf195868b38c
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1

$ git status
On branch master
nothing to commit, working tree clean

</code></pre>
И снова у нас «чистый директорий».
    <p>
Мы получили представление как работаю основные команды git.
Но чтобы полностью понять их работу и работу других команд git, надо знать внутреннее устройство репозитария.
</p>

<h2>Внутреннее устройство git</h2>

<p>
Повторим наш пример почти один в один. Только теперь будем рассматривать какие именно изменения в репозитории вызывают  уже рассмотренные нами команды.
</p>

<h3>Создание нового репозитария. Команда <i>git init</i></h3>

<p>
Создадим у себя на компьютере новый репозиторий в папке <i>project1.0</i>.
<pre><code style="color: blue">
$ mkdir ~/project1.0
   
$ cd ~/project1.0
   
$ git init
Initialized empty Git repository in .git/

$ git config user.name "Ivan Ivanov"
$ git config user.email "ivan@localhost"
</code></pre>
Проверим какие файлы папки есть внутри каталога <i>.git</i>.
    <p>
<pre><code style="color: blue">
$ ls -l .git
total 7
-rw-r--r-- 1 Konstantin 197121 181 июл 14 11:28 config
-rw-r--r-- 1 Konstantin 197121  73 июл 14 11:28 description
-rw-r--r-- 1 Konstantin 197121  23 июл 14 11:28 HEAD
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 hooks/
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 info/
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 objects/
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 refs/
</code></pre>
Имеем три файла и четыре каталога.
    <p>
Проверим наличие файлов внутри двух каталогов objects/ и refs/ или их подкаталогов.
<pre><code style="color: blue">
$ find .git/objects -type f

$ find .git/refs -type f
</code></pre>
Во в новом репозитории файлов в этих каталогах нет.
    <p>
Добавим в каталог репозитория два файла
<pre><code style="color: blue">
$ mkdir d

$ echo -n "File1 v1" > file1

$ echo -n "File2 v1" > d/file2
</code></pre>
    Добавление файлов в рабочий каталог никак не отражается на состоянии каталога .git!

    <h3>Команда <i>git add</i>. <i>Индекс</i>. Объекты типа <i>blob</i></h3>

<p>
Сделаем добавленные файлы отслеживаемыми. Начнем с файла d/file2.
<pre><code style="color: blue">
$ git add d/file2
</code></pre>
Посмотрим как эта операция отразилась на состоянии каталога <i>.git</i>.
    <p>
<pre><code style="color: blue">
$ ls -l .git
total 8
-rw-r--r-- 1 Konstantin 197121 181 июл 14 11:28 config
-rw-r--r-- 1 Konstantin 197121  73 июл 14 11:28 description
-rw-r--r-- 1 Konstantin 197121  23 июл 14 11:28 HEAD
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 hooks/
-rw-r--r-- 1 Konstantin 197121 104 июл 14 12:39 index
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 info/
drwxr-xr-x 1 Konstantin 197121   0 июл 14 12:39 objects/
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 refs/
</code></pre>
В <i>.git</i> появился новый файл <i>index</i>.
    <p>
<pre><code style="color: blue">
$ find .git/objects -type f
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f

$ find .git/refs -type f
</code></pre>
В <i>.git/objects</i> появился новый каталог <i>d</i> с файлом <i>fb6cc242d8ca8d2623b8deb4a1a17349af6f2f</i>.
    <p>
Все файлы образующиеся в процессе работы в каталоге <i>.git/objects/</i> называются <i>объектами</i>, а сам каталог - <i>базой объектов</i>.
<br>
Идентификаторы всех объектов являются 40- разрядными шестнадцатиричными числами.
<br>
Имя подкаталога в котором сохраняется объект - это подстрока из первых дву символов идентификатора объекта.
Имя файла - это подстрока из оставшихся 38 символов идентификатора.
<br>
Содержимое всех объектов, сжимается с помощью библиотеки zlib.
Поэтому если заглянуть внутрь файла <i>b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f</i>, то увидим мешанину символов.
<pre><code style="color: blue">
$ cat .git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
xK▒▒OR▒`p▒▒I5R(3%Uq
</code></pre>
    <p>
Распакуем наш объект <i>b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f</i> утилитой <i>gzip</i>.
<pre><code style="color: blue">
$ echo -en "\x1f\x8b\x08\x00\x00\x00\x00\x00" |cat - .git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f |gzip -dc
blob 8File2 v1
gzip: stdin: unexpected end of file
</code></pre>
Видим два поля:
<br> - некий заголовок: «blob 8»
<br> - и содержимое файла «d/file2»: «File2 v1».
<br>Примечания:
<br>1. слово «blob» тип объекта (Binary Large Object),
<br>2. число 8 - длина содержимого файла,
<br>3. идентификатор объекта - значение SHA-1 хеш-функции от содержимого объекта (до сжатия); в нашем случае от строки «blob 8\0File2 v1» (\0 - символ с нулевым код).
<br> Проверим последнее утверждение
<pre><code style="color: blue">
$ echo -en 'blob 8\0File2 v1' | sha1sum
b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f *-
</code></pre>
    Для информации:
    <br>
Объекты всех других типов также сжимаются с помощью библиотеки zlib.
<br>
Идентификаторы обьектов всех других типов также являются значение SHA-1 хеш-функции от содержимого объекта до сжатия.??????
<p>
Тип и содержимое объекта типа можно посмотреть командой <i>git cat-file</i>
<pre><code style="color: blue">
$ git cat-file -t b2fb
blob

$ git cat-file -p b2fb
File2 v1
</code></pre>
Рассмотрим файл <i>index</i> появившейся в каталоге <i>.git</i> после выполнения команды <i>git add</i>
<br>Непосредственный просмотр индекса утилитой <i>cat</i> также даёт мешанину символов (разве, что кроме имени файла)
<pre><code style="color: blue">
$ cat .git/index
▒▒&H]*▒4@ȫ▒]*▒4k▒X▒▒▒l▒B▒ʍ&#▒޴▒▒sI▒o/d/file2
▒1▒        ▒
</code></pre>
В понятном виде, почти всю информацию хранящуюся в индексе, можно посмотреть так
<pre><code style="color: blue">
$ git ls-files --stage
100644 b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f 0       d/file2
</code></pre>
Индекс состоит из записей. Сейчас у нас только одна запись.
<ul>
<li>   
Каждая запись состоит из четырех полей:
</li>   
<li>   
первое поле: атрибуты добавленного файла;
<br>первая группа из трих цифр - тип файла (040 - каталог, 100 - обычный файл, 120 - символическая ссылка, 160 - gitlink);
<br>вторая группа из трих - права доступа для владельца файла, для группы владельца и для остальных пользователей записанные как комбинация цифр 4, 2 и 1 (4 - право на чтение, 2 - право на запись, 1 - право на выполнение).
</li>   
<li>   
второе поле: идентификатор объекта, созданный на основе добавленного файла;
</li>   
<li>   
третье поле: stage number; 0 - если нет конфликта слияния (об этом позже);
</li>   
<li>   
последнее поле: добавленный командой <i>git add</i> файл, вместе с относительным путем до него.
</li>   
</ul>

    <p>
Сделаем отслеживаемым ещё один созданный нами файл file1.
<pre><code style="color: blue">
$ git add file1
</code></pre>
Посмотрим как эта операция отразилась на состоянии каталога .git.
    <p>
<pre><code style="color: blue">
$ ls -l .git
total 8
-rw-r--r-- 1 Konstantin 197121 181 июл 14 11:28 config
-rw-r--r-- 1 Konstantin 197121  73 июл 14 11:28 description
-rw-r--r-- 1 Konstantin 197121  23 июл 14 11:28 HEAD
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 hooks/
    -rw-r--r-- 1 Konstantin 197121 176 июл 14 15:12 index <span style="color: red"># было: 104 июл 14 12:39</span>
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 info/
drwxr-xr-x 1 Konstantin 197121   0 июл 14 15:12 objects/
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 refs/
</code></pre>
Изменились размер и время модификации файла <i>index</i>.
<br>
Новое содержимое индекса
<pre><code style="color: blue">
$ git ls-files --stage
100644 b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f 0       d/file2
100644 475190118d49d9905c1a82c6fd11dab9ab602cc4 0       file1
</code></pre>
Добавилась строчка об ещё одном отслеживаемом файле.
<br>
А какие изменения произошли в базе объектов?
<pre><code style="color: blue">
$ find .git/objects -type f
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4 <span style="color: red"># новый объект</span>
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
</code></pre>
В <i>.git/objects</i> появился новый объект <i>475190118d49d9905c1a82c6fd11dab9ab602cc4</i>.
    <p>
</p>

<h3>Команда <i>git commit</i></h3>

<p>
Выполним команду <i>git commit</i>.
<pre><code style="color: blue">
$ export GIT_AUTHOR_DATE="2000-01-01 00:01"

$ export GIT_COMMITTER_DATE="2000-01-01 00:01"

$ git commit -m "comment #1"
[master (root-commit) 69701b6] comment #1
 2 files changed, 2 insertions(+)
 create mode 100644 d/file2
 create mode 100644 file1
</code></pre>
Посмотрим как эта операция отразится на состоянии каталога <i>.git</i>.
<pre><code style="color: blue">
$ ls -l .git
total 9
-rw-r--r-- 1 Konstantin 197121  11 июл 15 07:44 COMMIT_EDITMSG <span style="color: red"># новый файл</span>
-rw-r--r-- 1 Konstantin 197121 181 июл 14 11:28 config
-rw-r--r-- 1 Konstantin 197121  73 июл 14 11:28 description
-rw-r--r-- 1 Konstantin 197121  23 июл 14 11:28 HEAD
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 hooks/
-rw-r--r-- 1 Konstantin 197121 235 июл 15 07:44 index <span style="color: red"># изменились размер и время модификации</span>
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 info/
drwxr-xr-x 1 Konstantin 197121   0 июл 15 07:44 logs/
drwxr-xr-x 1 Konstantin 197121   0 июл 15 07:44 objects/
drwxr-xr-x 1 Konstantin 197121   0 июл 14 11:28 refs/
</code></pre>
В каталоге <i>.git</i> появился новый файл <i>COMMIT_EDITMSG</i>, а файл <i>index</i>изменились.
    <p>
<pre><code style="color: blue">
$ git ls-files --stage <span style="color: red"># вывод команды прежний, несмотря на то, что сам файл index изменился; в индексе содержится больше информации, чем показывает эта команда :)</span>
100644 b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f 0       d/file2
100644 475190118d49d9905c1a82c6fd11dab9ab602cc4 0       file1

$ find .git/objects -type f
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/69/701b6e701d429882c083e98e1ecf195868b38c <span style="color: red"># новый объект</span>
.git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4 <span style="color: red"># новый объект</span>
.git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9 <span style="color: red"># новый объект</span>
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f

$ find .git/refs -type f
.git/refs/heads/master <span style="color: red"># новый файл</span>

$ git cat-file -t b2fb
blob <span style="color: red"># это уже известный нам blob-объект</span>

$ git cat-file -t 6970
commit <span style="color: red"># это новый, для нас, тип объекта - commit</span>

$ git cat-file -t 6c59
tree <span style="color: red"># это новый, для нас, тип объекта - tree</span>

$ git cat-file -t 966e
tree <span style="color: red"># ещё один объект tree-типа</span>
</code></pre>
Сначала посмотрим что хранят новые файлы
<pre><code style="color: blue">
$ cat .git/COMMIT_EDITMSG <span style="color: red"># этот файл хранит сообщение нашего коммита</span>
comment #1

$ cat .git/refs/heads/master
69701b6e701d429882c083e98e1ecf195868b38c <span style="color: red"># этот файл хранит идентификатор созданного commit-объекта</span>
</code></pre>
    <p>
Все файла создаваемые в каталоге <i>.git/refs/heads/</i> в процессе работы содержат идентификаторы каких-либо commit-объектов.
Такого типа файлы называются <i>указателями</i>.
Т.о. у нас появился первый указатель с именем <i>master</i>.
</p><p>
Для просмотра всех существующих указателей имеется команда git <i>git branch</i> (без параметров) :
<pre><code style="color: blue">
$ git branch
* master
</code></pre>
    <p>
А идентификатор коммита, хранящийся в указателе &lt;name&gt; можно посмотреть командой <i>git rev-parse &lt;name&gt;</i>, например:
<pre><code style="color: blue">
$ git rev-parse master
69701b6e701d429882c083e98e1ecf195868b38c
</code></pre>
    <p>
Команда <i>git commit</i> создала новые, для нас типы объектов <i>tree</i> и <i>commit</i>.
Давайте разберемся что они из себя представляют.
</p>

<h3>Объекты типа <i>tree</i></h3>

<p>
Посмотреть содержимое дерева можно, командой <i>cat-file</i> с ключем <i>-p</i> или специальной командой <i>git ls-tree</i>.
</p><p>
У наших двух деревьев такое содержание
<pre><code style="color: blue">
$ git cat-file -p 6c59
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 475190118d49d9905c1a82c6fd11dab9ab602cc4    file1

$ git cat-file -p 966e
100644 blob b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f    file2
</code></pre>
    <p>
</p>

<p>
Дерево хранит список записей файлов и каталогов, а также соответствующих им объектов.
Каждая запись в дереве состоит из четырех полей:
<ul>
<li>
    Первое поле: атрибуты файла (или каталога) [аналогично имеющемуся в индексе];
    <ul>
		<li>
		первая группа из трих цифр - тип файла (040 - каталог, 100 - обычный файл, 120 - символическая ссылка, 160 - gitlink); 
		<li>
		вторая группа из трих - права доступа для владельца файла, для группы владельца и для остальных пользователей записанные как комбинация цифр 4, 2 и 1 (4 - право на чтение, 2 - право на запись, 1 - право на выполнение). 
	</ul>
<li>
    Второе поле: тип объекта. Может быть <i>blob</i> или <i>tree</i>.
</li>
<li>
    Третье поле: идентификатор объекта.
</li>
<li>
    Четвертое поле: имя файла, если тип объекта - <i>blob</i>, или имя директории, если - <i>tree</i>.
</li>
</ul>
    <p>
Идентификатор дерева является значением SHA1 хеш-функции от всей информации которую оно хранит.
Структура этой информации соответствует вышеприведенному описанию. При этом поля разделяются знаками ???, а записи знаками???
Эта структура, как уже говорилось, хранится в сжатом виде.
</p><p>
Дерево git-а аналогично каталогу файловой системы, а blob аналогичен inode.
Деревья образуют иерархию, аналогичную иерархии каталогов и файлов.
</p><p>
Деревья объединяют blob-объекты и деревья в иерархии, аналогичные каталогам файловой системе.
</p><p>
Деревья строятся по команде <i>git commit</i> на основании информации содержащийся в индексе, а не фактического содержания рабочего каталога в момент выполнения команды! Это очень важно для понимания работы git.
</p><p>
<i>Снимок (snapshot) системы</i> - это дерево рабочего каталога вместе со всеми объектами на которые оно по цепочке ссылается.
</p><p>
Мы имеем первый снимок нашей системы
<pre><code style="color: blue">
6c59 ---+--&gt; 4751 (файл «file1»)
        |
        +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
    <p>
   Что следует из того, что идентификаторы блобов, деревьев, как и всех остальных объектов, являются хешем их содержимого?
   Если у двух объектов-деревьев одинаковые идентификаторы,
   это означает что внутренности этих деревьев совпадают!
   А так как внутренности деревьев - это ссылки на объекты, то это означает что два дерева ссылаются на одни и те же объекты. Которые в свою очередь тоже могут быть деревьями или блобами.
   Таким образом идентификатор дерева на самом деле идентифицирует не только "файлы в одной директории", но и все файлы во всех поддиректориях этой директории - одно имя для всей иерархии!
</p><p>
   Это свойство позволяет git-у очень быстро производить сравнение
   деревьев со сколь угодно сложной иерархией, уровнями вложенности и т.д.
   без чтения собственно содержимого - blob-ов или tree.
</p>

<h3>Объекты типа <i>commit</i></h3>

<p>
Содержимое коммита можно посмотреть командой <i>cat-file</i> с ключем <i>commit</i> или  с ключем <i>-p</i>.
</p><p>
Посмотрим содержимое нашего первого коммита
<pre><code style="color: blue">
$ git cat-file -p 6970
tree 6c59b709d4abf607ab16a03b22db93412fe437a4
author Ivan Ivanov &lt;ivan@localhost&gt; 946677660 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677660 +0200

comment #1
</code></pre>
    <p>
   Объект-commit состоит из следующих полей:
<ul>
<li>ссылка на объект-дерево, который хранит иерархию рабочего каталога;</li>   
<li>ссылка на родителя (parent), если таковой есть (у нас пока нет);</li>   
<li>author – это человек, внесший изменения в файлы проекта;</li>   
<li>время создания изменений;</li>   
<li>committer - это человек, внесший изменения в историю проекта, т.е. выполнивший команду git commit;</li>   
<li>время фиксации изменений;</li>   
<li>сообщение - пояснительный текст к коммиту.</li>
</ul>
Если родителей несколько, то ссылка на каждого из родителей выводится на отдельной строчке.
    <p>
Что такое родитель коммита?
Это другой, уже существующие в системе, commit-объект, на основе которого строится данный коммит объект.
Что это конкретно означает рассмотрим позже.
</p><p>
Стандартная ситуация - у каждого коммита один родитель.
</p><p>
Поскольку у нас это первый коммит, то никаких других до него небыло, а значит и родителей у первого коммита быть не может.
</p><p>
Поля author и committer и их почтовые адреса заполняются на основании переменных окружения «GIT_AUTHOR_NAME», «GIT_AUTHOR_EMAIL», «GIT_COMMITTER_NAME», «GIT_COMMITTER_EMAIL».
Если эти переменные окружения не установлены, то значения берутся из локального файла конфигурации. А если и в нем не установлены то из глобального файла конфигурации.
</p><p>
Как правило временем создании и фиксации изменений считается текущее время.
Однако если установлена переменные окружения «GIT_AUTHOR_DATE» и «GIT_COMMITTER_DATE» , то время создании и фиксации изменений устанавливается на основании значений этих переменных окружения.
Как правило эти переменные окружения не установлены. Это требуется только в учебных примерах.
</p><p>
При помощи параметров --author=<i>имя &lt;email&gt;</i> и --date=<i>время</i> команды <i>git commit</i> также можно переопределить значения, но только для полей author и время создания изменений.
</p><p>
Зачем в учебных примерах может понадобиться устанавливать переменные окружения «GIT_AUTHOR_DATE» и «GIT_COMMITTER_DATE»?
</p><p>
Наличие в объекте commit имени автора и коммитера, а также времени создания и фиксации изменений приводит к тому, что идентификаторы создаваемых коммитов зависят от этих значений.
И при повторении примеров идентификаторы коммитов будут получаться иными.
Иногда это неудобно. В таких случаях автора и коммитера мы будем устанавливать в локальном файле конфигурации:
<pre><code style="color: blue">
git config user.name "Ivan Ivanov"
git config user.email "ivan@localhost"
</code></pre>
а время задавать в командной строке:
<pre><code style="color: blue">
$ export GIT_AUTHOR_DATE="2000-01-01 00:00:00"
$ export GIT_COMMITTER_DATE="2000-01-01 00:00:00"
</code></pre>
    <p>
Коммиты могут порождаться разными командами.
Основная команда это <i>git commit</i>.
Эта команда может создать коммит только с одним родителем - <i>текущим коммитом</i>.
<br>
<i>Текущий коммит</i> - коммит идентификатор которого хранится <i>текущем указателе</i>.
<br>
<i>Текущий указатель</i> - указатель имя которого хранится в файле <i>.git/HEAD</i>.
</p><p>
<pre><code style="color: blue">
$ cat .git/HEAD
ref: refs/heads/master

$ cat .git/refs/heads/master
69701b6e701d429882c083e98e1ecf195868b38c
</code></pre>
У нас текущий (и единственный) указатель <i>master</i>.
Текущий (и единственный) коммит <i>69701b6e701d429882c083e98e1ecf195868b38c</i>.
    <p>
Уже говорилось, что список всех существующих указателей выводит команда git <i>git branch</i> (без параметров) :
<pre><code style="color: blue">
$ git branch
* master
</code></pre>
Текущий коммит в списке выделяется звездочкой.
    <p>
Идентификатор коммита, хранящийся в указателе &lt;name&gt; можно посмотреть командой <i>git rev-parse &lt;name&gt;</i>, например:
<pre><code style="color: blue">
$ git rev-parse master
69701b6e701d429882c083e98e1ecf195868b38c
</code></pre>
    <p>
Если коммит «B» имеет родителем коммит «A» (A ← B), то «B» для «A» является потомком (child).
</p><p>
Если в  репозитории есть коммиты которые являются предками для нескольких коммитов, то говорят о <i>ветвлении</i> коммитов.
<br>
Если в репозитории есть коммиты у которых более одного предка, то говорят о <i>слиянии</i> коммитов.
<br>
Репозитории без ветвлений и слияний называется <i>линейными</i>.
</p>
Автором и коммитером обычно бывает один человек. В этом случае поля author и committer совпадают.
    <p>
Каманда <i>git log</i> выводит информацию о всех??? комитах.
Но по каждому коммиту видно немного меньше информации, чем выдает <i>git cat-file -p</i>.
Сейчас у нас один коммит. И <i>git log</i> выведет информацию только по нему.
<pre><code style="color: blue">
$ git log
commit 69701b6e701d429882c083e98e1ecf195868b38c (HEAD -> master)
Author: Ivan Ivanov &lt;ivan@localhost&gt;
Date:   Sat Jan 1 00:01:00 2000 +0200

    comment #1
</code></pre>
    <p>
Продолжим рассмотрение нашего примера.
Создадим в рабочем каталоге еще один файл
и сделаем его отслеживаемым
<pre><code style="color: blue">
$ echo -n "File3 v1" > file3

$ git add file3
</code></pre>

    <p>
Что поменялось?
<pre><code style="color: blue">
$ ls -l .git/index
-rw-r--r-- 1 Konstantin 197121 288 июл 15 14:04 .git/index

$ git ls-files --stage
100644 b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f 0       d/file2
100644 475190118d49d9905c1a82c6fd11dab9ab602cc4 0       file1
100644 ad2a32f77c6c6eac140b94619e332c89d1319b6b 0       file3

$ find .git/objects -type f
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/69/701b6e701d429882c083e98e1ecf195868b38c
.git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4
.git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9
.git/objects/ad/2a32f77c6c6eac140b94619e332c89d1319b6b <span style="color: red"># новый объект</span>
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
</code></pre>
Снова изменился индекс.
В него добавилась новая строка для нового отслеживаемого файла.
И появился новый blob-объект в базе объектов.
    <p>
Выполним фиксацию
<pre><code style="color: blue">
$ export GIT_AUTHOR_DATE="2000-01-01 00:02"

$ export GIT_COMMITTER_DATE="2000-01-01 00:02"

$ git commit -m "comment #2"
[master 03c1a7f] comment #2
 1 file changed, 1 insertion(+)
 create mode 100644 file3
</code></pre>
    <p>
Что поменялось?
<pre><code style="color: blue">
$ ls -l .git/index
-rw-r--r-- 1 Konstantin 197121 307 июл 15 14:53 .git/index

$ git ls-files --stage
100644 b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f 0       d/file2
100644 475190118d49d9905c1a82c6fd11dab9ab602cc4 0       file1
100644 ad2a32f77c6c6eac140b94619e332c89d1319b6b 0       file3

$ find .git/objects -type f
.git/objects/03/c1a7f12800978dde0b8cd6383595e7007d0098 <span style="color: red"># новый объект</span>
.git/objects/27/63fac853abca428edd5c2a1b48ef5d212ff99a <span style="color: red"># новый объект</span>
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/69/701b6e701d429882c083e98e1ecf195868b38c
.git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4
.git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9
.git/objects/ad/2a32f77c6c6eac140b94619e332c89d1319b6b
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f

$ git cat-file -t 03c1
commit

$ git cat-file -t 2763
tree

$ git cat-file -p 03c1
tree 2763fac853abca428edd5c2a1b48ef5d212ff99a
parent 69701b6e701d429882c083e98e1ecf195868b38c
author Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200

comment #2

$ git cat-file -p 2763
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 475190118d49d9905c1a82c6fd11dab9ab602cc4    file1
100644 blob ad2a32f77c6c6eac140b94619e332c89d1319b6b    file3
</code></pre>
Снова изменился индекс (однако вывод команды <i>git ls-files --stage</i> не изменился).
<pre><code style="color: blue">
$ git branch
* master
</code></pre>
    <p>
Текущий указатель попрежнему <i>master</i>
<pre><code style="color: blue">
$ git rev-parse master
03c1a7f12800978dde0b8cd6383595e7007d0098
</code></pre>
Текущий коммит сменился на <i>03c1a7f12800978dde0b8cd6383595e7007d0098</i>
<pre><code style="color: blue">
$ git cat-file -p 03c1
tree 2763fac853abca428edd5c2a1b48ef5d212ff99a
parent 69701b6e701d429882c083e98e1ecf195868b38c
author Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200

comment #2
</code></pre>
Новый коммит указывает на новое дерево.
Родителем нового коммита является наш первый коммит
    <p>
Новый снимок системы
<pre><code style="color: blue">
2763 ---+--&gt; 4751 (файл «file1»)
        |
        +--&gt; ad2a (файл «file3»)
        |
        +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
    <p>
Изменим содержимое файла file3, добавив еще одну строку
<pre><code style="color: blue">
$ echo -ne "\nSecond line (v2)" >> file1
</code></pre>
Подготовим для фиксации новую версию файла file1.
<pre><code style="color: blue">
$ git add file1

$ git ls-files --stage
100644 b2fb6cc242d8ca8d2623b8deb4a1a17349af6f2f 0       d/file2
100644 1d5260cb0591933230fdaaa8035a94b8e393ea20 0       file1 <span style="color: red"># поменялся идентификатор</span>
100644 ad2a32f77c6c6eac140b94619e332c89d1319b6b 0       file3

$ find .git/objects -type f
.git/objects/03/c1a7f12800978dde0b8cd6383595e7007d0098
.git/objects/1d/5260cb0591933230fdaaa8035a94b8e393ea20 <span style="color: red"># новый объект</span>
.git/objects/27/63fac853abca428edd5c2a1b48ef5d212ff99a
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/69/701b6e701d429882c083e98e1ecf195868b38c
.git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4
.git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9
.git/objects/ad/2a32f77c6c6eac140b94619e332c89d1319b6b
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
</code></pre>
Замечание: Когда команда <i>git add</i> выполняется с модифицированным файлом, она не добавляет, а изменяет уже имеющуюся запись в индексе.
    <p>
Фиксируем новое состояние.
<pre><code style="color: blue">
$ export GIT_AUTHOR_DATE="2000-01-01 00:03"

$ export GIT_COMMITTER_DATE="2000-01-01 00:03"

$ git commit -m "comment #3"
[master 344b36b] comment #3
 1 file changed, 2 insertions(+), 1 deletion(-)
</code></pre>
    <p>
Что поменялось?
<pre><code style="color: blue">
$ find .git/objects -type f
.git/objects/03/c1a7f12800978dde0b8cd6383595e7007d0098
.git/objects/1d/5260cb0591933230fdaaa8035a94b8e393ea20
.git/objects/27/63fac853abca428edd5c2a1b48ef5d212ff99a
.git/objects/34/4b36ba2aeb489f97a4928816eeeefb30ddfac2 <span style="color: red"># новый объект</span>
.git/objects/47/5190118d49d9905c1a82c6fd11dab9ab602cc4
.git/objects/69/701b6e701d429882c083e98e1ecf195868b38c
.git/objects/6c/59b709d4abf607ab16a03b22db93412fe437a4
.git/objects/96/6e9a46c8df9aa3b2108864be07abe7b5d1d0f9
.git/objects/ad/2a32f77c6c6eac140b94619e332c89d1319b6b
.git/objects/b2/fb6cc242d8ca8d2623b8deb4a1a17349af6f2f
.git/objects/b8/92ad555729a5275bb9ba81158e2a708da84b11 <span style="color: red"># новый объект</span>

$ git cat-file -t 03c1
commit

$ git cat-file -t b892
tree

$ git cat-file -p 03c1
tree 2763fac853abca428edd5c2a1b48ef5d212ff99a
parent 69701b6e701d429882c083e98e1ecf195868b38c
author Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200
committer Ivan Ivanov &lt;ivan@localhost&gt; 946677720 +0200

comment #2

$ git cat-file -p b892
040000 tree 966e9a46c8df9aa3b2108864be07abe7b5d1d0f9    d
100644 blob 1d5260cb0591933230fdaaa8035a94b8e393ea20    file1
100644 blob ad2a32f77c6c6eac140b94619e332c89d1319b6b    file3
</code></pre>
Появилось новое дерево и новый коммит.
    <p>
Вот новый снимок системы
<pre><code style="color: blue">
b892 ---+--&gt; 1d52 (файл «file1» v2)
        |
        +--&gt; ad2a (файл «file3»)
        |
        +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
А так выгладит вся история нашего репозитория.
<pre><code style="color: blue">
6970 (commit #1) --&gt; 6c59 ---+--&gt; 4751 (файл «file1»)
|                            |
|                            +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
↓
03c1 (commit #2) --&gt; 2763 ---+--&gt; 4751 (файл «file1»)
|                            |
|                            +--&gt; ad2a (файл «file3»)
|                            |
|                            +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
↓
344b (commit #3) --&gt; b892 ---+--&gt; 1d52 (файл «file1» v2)
                             |
                             +--&gt; ad2a (файл «file3»)
                             |
                             +--&gt; 966e (каталог «d») --&gt; 4751 (файл «file2»)
</code></pre>
    <p>
Таже история в обратной хронологической последовательности и без подробностей
<pre><code style="color: blue">
$ git log --graph
* commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (HEAD -> master)
| Author: Ivan Ivanov &lt;ivan@localhost&gt;
| Date:   Sat Jan 1 00:03:00 2000 +0200
|
|     comment #3
|
* commit 03c1a7f12800978dde0b8cd6383595e7007d0098
| Author: Ivan Ivanov &lt;ivan@localhost&gt;
| Date:   Sat Jan 1 00:02:00 2000 +0200
|
|     comment #2
|
* commit 69701b6e701d429882c083e98e1ecf195868b38c
  Author: Ivan Ivanov &lt;ivan@localhost&gt;
  Date:   Sat Jan 1 00:01:00 2000 +0200

      comment #1
</code></pre>

    <h3>Восстановление предыдущих состояний рабочего каталога. Команда <i>git checkout</i></h3>

<p>
Мы говорили что СКВ должны уметь восстанавливать историю.
Как это сделать в git?
</p><p>
Откатить состояние рабочего каталога на состояние соответствующее &lt;id-commit&gt; можно командой <i>git checkout &lt;id-commit&gt;</i>
<pre><code style="color: blue">
$ git checkout 03c1
Note: checking out '03c1'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at 03c1a7f comment #2
</code></pre>
Проверьте состояние рабочего каталога
    <p>
Мы говорили, что файле <i>.git/HEAD</i> хранит имя текущего указателя, который ссылается на текущий коммит.
Что там сейчас?
<pre><code style="color: blue">
$ cat .git/HEAD
03c1a7f12800978dde0b8cd6383595e7007d0098
</code></pre>
Там вместо имени текущего указателя там находится идентификатор текущего коммита, который мы назначили командой <i>git checkout</i>
    <p>
Продвинемся ещё дольше в историю
<pre><code style="color: blue">
$ git checkout 6970
Previous HEAD position was 03c1a7f comment #2
HEAD is now at 69701b6 comment #1
</code></pre>
Снова проверьте состояние рабочего каталога и содержимое <i>.git/HEAD</i>.
<pre><code style="color: blue">
$ cat .git/HEAD
69701b6e701d429882c083e98e1ecf195868b38c
</code></pre>
Вернем к последнему состоянию
<pre><code style="color: blue">
$ git checkout master
Previous HEAD position was 69701b6 comment #1
Switched to branch 'master'

$ cat .git/HEAD
ref: refs/heads/master
</code></pre>
И снова у нас последнее сохраненное состояние,
а в <i>.git/HEAD</i> указатель <i>master</i>

    <h3>О ветвлении и ветках</h3>

<p>
Работая над проектом вам может потребоваться отклониться от основной линии разработки и продолжить работу независимо от нее, не вмешиваясь в основную линию.
По завершении такой работа, как правило, нужно перенести наработки в основную линию.
Такие действия, при работе с проектом, называются <i>ветвлением</i> <i>и слиянием</i>.
Ветвление в любой СКВ можно организовать путем копирования всего проекта.
Однако такой способ ветвления является долгим и затратным.
</p><p>
В Git ветвление очень легковесно и операции создания ветки выполняется почти мгновенно.
Git поощряет процесс работы, при котором ветвление и слияние выполняется часто, даже по несколько раз в день.
Понимание и владение этой функциональностью дает вам уникальный и мощный инструмент.
</p><p>
В документации по git постоянно используется термин <i>ветка</i>.
Однако в разных местах в этот термин вкладывается разный смысл.
То это некая последовательность коммитов, то указатель на коммит.
Мы указатели ветками никогда называть не будем.
</p><p>
<i>Веткой</i> будем называть цепочку коммитов, начинающуюся с отмеченного каким нибуть указателем коммита, и идущую вниз до первого ветвящегося коммита; а если такового нет, то до корневого коммита.
</p><p>
Т.о. каждому указателю соответствует своя ветку.
Имя указателя используется как имя соответствующей ему ветки.
</p><p>
А теперь давайте разберемся как в git реализовано ветвление.
Но начнем мы с создания указателей.
</p>

<h3>Создание новых указателей. Команда <i>git branch</i></h3>

<p>
До сих пор у нас существовал только один, автоматически созданный, указатель <i>master</i>.
</p><p>
Но прочие указатели, как правило, мы будем создавать сами.
Для этого имеется команда <i>git branch &lt;name&gt; &lt;id-commit&gt;</i>
</p><p>
Создадим указатель с именем <i>test</i> указывающий на второй коммит с идентификатором <i>03c1</i>.
<pre><code style="color: blue">
$ git branch test 03c1

$ git branch
* master
  test
</code></pre>
У нас теперь два указателя.
Текущим по прежнему является указатель <i>master</i>.
    <p>
Новый указатель теперь можно использовать во всех командах вместо &lt;id-commit&gt;,
в том числе в команде <i>git checkout</i>
<pre><code style="color: blue">
$ git checkout test
Switched to branch 'test'

$ cat .git/HEAD
ref: refs/heads/test

$ git checkout master
Switched to branch 'master'

$ cat .git/HEAD
ref: refs/heads/master
</code></pre>
Что произойдет, если
текущим указателем сделать указатель <i>test</i> (тем самым вернув рабочий каталог к состоянию на момент второго коммита),
внести изменения в какой-либо файл и зафиксировать получившееся состояние?
<pre><code style="color: blue">
$ git checkout test
Switched to branch 'test'

$ cat file3
File3 v1

$ echo -n "File3 ver2" >> file3

$ cat file3
File3 v1File3 ver2

$ git add .

$ export GIT_AUTHOR_DATE="2000-01-01 00:04"

$ export GIT_COMMITTER_DATE="2000-01-01 00:04"

$ git commit -m "comment #4"
[test 6fff0ca] comment #4
 1 file changed, 1 insertion(+), 1 deletion(-)

$ git log --graph --all
* commit 6fff0ca362c2115be66b404992f61fe8fd9d3631 (HEAD -> test)
| Author: Ivan Ivanov &lt;ivan@localhost&gt;
| Date:   Sat Jan 1 00:04:00 2000 +0200
|
|     comment #4
|
| * commit 344b36ba2aeb489f97a4928816eeeefb30ddfac2 (master)
|/  Author: Ivan Ivanov &lt;ivan@localhost&gt;
|   Date:   Sat Jan 1 00:03:00 2000 +0200
|
|       comment #3
|
* commit 03c1a7f12800978dde0b8cd6383595e7007d0098
| Author: Ivan Ivanov &lt;ivan@localhost&gt;
| Date:   Sat Jan 1 00:02:00 2000 +0200
|
|     comment #2
|
* commit 69701b6e701d429882c083e98e1ecf195868b38c
  Author: Ivan Ivanov &lt;ivan@localhost&gt;
  Date:   Sat Jan 1 00:01:00 2000 +0200

      comment #1
</code></pre>
Наша прежде линейная история разветвилась.
Коммит <i>03c1</i> стал родителем уже двух коммитов.

    <h3>Пример использования ветвления и слияния</h3>

<p>
Создадим у себя на компьютере пустую папку и сделаем её <i>репозиторием Git</i>.
<pre><code style="color: blue">
$ mkdir ~/project2
   
$ cd ~/project2
   
$ git init
Initialized empty Git repository in .git/

$ git config user.name "Ivan Ivanov"

$ git config user.email "ivan@localhost"

$ nano dev.py
</code></pre>

<pre><code style="color: blue">
x = 6
y = 2
print("x/y=",x/y)
</code></pre>

<pre><code style="color: blue">
$ git add .

$ git commit -m "v1"
[master (root-commit) afb5303] v1
 1 file changed, 3 insertions(+)
 create mode 100644 dev.py

D:\Git\project2>python dev.py
x/y= 3
</code></pre>
Пишем вторую версию программы
<pre><code style="color: blue">
$ nano dev.py
</code></pre>

<pre><code style="color: blue">
x = int(input("x="))
y = int(input("y="))
print("x/y=",x/y)
print("Спасибо за использование нашей программы!")
</code></pre>

<pre><code style="color: blue">
$ git add .

$ git commit -m "v2"
[master (root-commit) afb5303] v1
 1 file changed, 3 insertions(+)
 create mode 100644 dev.py

D:\Git\project2>python dev.py
x=9
y=2
x/y= 4.5
</code></pre>
Получаем задание «улучшить» интерфейс.
Выполнять это задание будем в новой ветке «testing».
<pre><code style="color: blue">
$ git branch testing

$ git checkout testing

$ nano dev.py
</code></pre>

<pre><code style="color: blue">
x = int(input("x="))
y = int(input("y="))
print("x/y=",x/y)
print("Спасибо за использование нашей программы!")
# работаем ....
# ещё работаем ....
# и снова работаем ....
</code></pre>
Но тут обнаружился "баг" в нашей программе.
При делении на ноль наша программа некорректно завершает работу с выдачей непонятного для пользователя сообщения.
    <p>
Получаем новое задание: отложить все дела и срочно устранить "баг".
</p><p>
<pre><code style="color: blue">
$ git add .

$ git commit -m "незавершенная версия с улучшенным интерфейсом"

$ git checkout master

$ git branch hotfix

$ git checkout hotfix

$ nano dev.py
</code></pre>

<pre><code style="color: blue">
x = int(input("x="))
y = int(input("y="))
if = 0:
	print("x/y=",x/y)
else:
	print("Извините, но делить на ноль нельзя")
print("Спасибо за использование нашей программы!")
</code></pre>

</div>
</BODY></HTML>
