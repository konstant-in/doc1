<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<TITLE>?????????</TITLE>
<meta name="KeyWords" content="git">
</HEAD>
<BODY BGCOLOR="#DDE1C2" TEXT="#002040">

<div style="width:85%;  margin: auto;">

<h3>Создание клонов репозитория</h3>

<p>
</p>
<p>
</p>

<h3>Удаленные репозитории</h3>

<p>
Git позволяет работая в одном репозитории получать и принимать изменения из другого репозитория.
В этом случае первый репозиторий называется <i>локальным</i>, а второй - <i>удаленным</i>.
</p>
<p>
Удаленный репозиторий может располагаться на том же компьютере, что и локальный, в локальной сети, или где то в интернете. Главное у пользователя должен быть доступ одним из способов, который поддерживает git.
Для получения изменений достаточно иметь доступ на чтение, для передачи изменений - доступ на запись.
</p>

****************************
<p>
Удаленные репозитории могут бать двух видов: обычные (которые мы рассматривали до сих пор) и голые (bare).
Обычные только для чтения??????????????
</p>

****************************

<p>
Создадим два репозитория на одном компьютере.
Каждый их них является по отношению к другому удаленным.
(Пример для Linux.)
</p>

****************************

<h3>Создание клонов репозитория</h3>

****************************

<p>
</p>

****************************

<h3>Работа с удаленным репозиторием</h3>

<p>
Для начала надо <i>подсоединить</i> к локальному удаленный репозиторий, т.е. присвоить удалённому репозиторию имя (shortname) и указать его URL.
Подсоединение выполняется командой git remote add &lt;shortname&gt; &lt;url&gt;.
Она сохраняет имя и URL удаленного репозитория в локальном конфигурационном файле.
</p>
<p>
При клонировании репозитория происходит подсоединение клонированного репозитория как удаленного, с именем «origin».
</p>
<p>
Командой <i>git remote</i> без параметров можно посмотреть список всех подсоединенных удаленных репозиториев.
Эта же команда с параметром «-v» выводит дополнительно URL удаленных репозиториев.
URL для чтения (fetch) и записи (push), в общем случае, может отличаться.
Но даже если они совпадают, команда выводит две строки на каждый удаленный репозиторий.
(В результате какой команды могут получиться разные URL для чтения и записи???????????????).
<pre><code><font color="#461b7e">
$ git remote
origin

$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
</font></code></pre>
</p>

<h3>Удалённые указатели и удалённые ветки</h3>

<p>
Вы помните, что указатели представляют из себя файла в каталоге <i>.git/refs/heads/</i> содержат идентификаторы каких-либо commit-объектов.
<i>Удаленные указатели</i> - это файлы в каталоге <i>.git\refs\remotes\&lt;имя_удаленного_репозитория&gt;</i> содержащие идентификаторы commit-объектов этого удаленного репозитория.
У этом репозитории содержатся копии всех указателей удаленного репозитория в том состоянии, в каком они были во время последнего выполнения команды <i>git fetch</i>, <i>git pull</i> или <i>git clone</i>.
Если локальные указатели двигаются когда мы делаем коммиты в локальном репозитории, то удаленные указатели двигаются, когда мы «осуществляем связь» с удаленным репозиторием.
</p>
<p>
В каталоге <i>.git\refs\remotes\&lt;имя_удаленного_репозитория&gt;</i> помимо копий указателей удаленного репозитория хранится копия файла <i>.git\HEAD</i>
</p>
<p>
Обращения к указателям (веткам) удаленного репозитория выглядят так: <code>&lt;имя_удаленного_репозитория&gt;/&lt;имя_указателя/ветки&gt;</code>.
Например, если вы хотите посмотреть, как выглядела ветка <code>master</code> на сервере <code>origin</code> во время последнего соединения с ним, проверьте ветку <code>origin/master</code>.
Если вы с партнёром работали над одной проблемой, и он выложил ветку <code>iss53</code>, у вас может быть своя локальная ветка <code>iss53</code>; но та ветка на сервере будет указывать на коммит в <code>origin/iss53</code>.</p>

****************************

<h3>Голые репозитори</h3>

****************************

<h3>Работа с удаленными репозиториями по сети</h3>

****************************

<h3>Отправка изменений. Команда <i>git push</i></h3>

<p>
Когда вы хотите поделиться веткой с окружающими, вам необходимо отправить (push) её на удалённый сервер, на котором у вас есть права на запись.
Не все ваши локальные ветки будут синхронизируются с удалёнными репозиториями.
Вам нужно явно указать те ветки, которыми вы хотите поделиться.
Так вы можете отправлять только те тематические ветки, над которыми вы работаете с кем-то совместно,
и не отправлять свои личные ветки для работы, которую вы не хотите показывать.
</p>

<p>
Если у вас есть ветка <code>serverfix</code>, над которой вы хотите работать с кем-то ещё, вы можете отправить её точно так же, как вы отправляли вашу первую ветку.
<br>
Выполните <code>git push &lt;имя_удаленного_репозитория&gt; &lt;имя_ветки&gt;</code>:
</p>

<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -&gt; serverfix</code></pre>

<p>
Это в некотором роде сокращение.
Git автоматически разворачивает имя ветки <code>serverfix</code> до <code>refs/heads/serverfix:refs/heads/serverfix</code>, что означает “возьми мою локальную ветку serverfix и обнови ей удалённую ветку serverfix.”
Вы также можете выполнить <code>git push origin serverfix:serverfix</code> — произойдёт то же самое — здесь говорится “возьми мой serverfix и сделай его удалённым serverfix.”
Можно использовать этот формат для отправки локальной ветки в удалённую ветку с другим именем.
Если вы не хотите, чтобы ветка называлась <code>serverfix</code> на удалённом сервере, то вместо предыдущей команды выполните <code>git push origin serverfix:awesomebranch</code>.
Так ваша локальная ветка <code>serverfix</code> отправится в ветку <code>awesomebranch</code> удалённого проекта.
</p>

<p>В следующий раз, когда один из ваших соавторов будет получать обновления с сервера, он получит ссылку на то, на что указывает <code>serverfix</code> на сервере, как удалённую ветку <code>origin/serverfix</code>:</p>


<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -&gt; origin/serverfix</code></pre>


<p>Важно отметить, что когда при получении данных у вас появляются новые удалённые ветки, вы не получаете автоматически для них локальных редактируемых копий.
Другими словами, в нашем случае вы не получите новую ветку <code>serverfix</code> — только указатель <code>origin/serverfix</code>, который вы не можете менять.</p>

<p>Чтобы слить эти наработки в свою текущую рабочую ветку, выполните <code>git merge origin/serverfix</code>.
Если вам нужна своя собственная ветка <code>serverfix</code>, над которой вы сможете работать, то вы можете создать её на основе удалённой ветки:</p>

<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</code></pre>

<p>Это даст вам локальную ветку, на которой можно работать. Она будет начинаться там, где и <code>origin/serverfix</code>.</p>


<h3 id="r_tracking_branches">Отслеживание веток</h3>

<p>
Получение локальной ветки из удалённой ветки автоматически создаёт то, что называется “отслеживаемой веткой” (или иногда “upstream branch”).
Отслеживаемые ветки — это локальные ветки, которые напрямую связаны с удалённой веткой.
Если, находясь на отслеживаемой ветке, вы наберёте <code>git pull</code>, Git уже будет знать, с какого сервера получить все удалённые ссылки и сделает слияние с соответствующей удалённой веткой. Аналогично выполнение <code>git pull</code> на одной из таких веток, сначала получает все удалённые ссылки, а затем автоматически делает слияние с соответствующей удалённой веткой.</p>

<p>При клонировании репозитория, как правило, автоматически создаётся ветка <code>master</code>, которая отслеживает <code>origin/master</code>.
Однако, вы можете настроить отслеживание и других веток, допустим если вы хотите, чтобы одни ветки отслеживались с другого удаленного репозитория или не хотите отслеживать ветку <code>master</code>.
Простой пример, как это сделать, вы увидели только что — <code>git checkout -b [ветка] [удал. сервер]/[ветка]</code>.
Существует общепринятая операция, которую git предоставляет, <code>--track</code>:</p>

<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</code></pre>

<p>Чтобы настроить локальную ветку с именем, отличным от имени удалённой ветки, вы можете легко использовать первую версию с другим именем локальной ветки:</p>

<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'</code></pre>

<p>Теперь ваша локальная ветка sf будет автоматически получать (pull) изменения из origin/serverfix.</p>

<p>Если у вас уже есть локальная ветка и вы хотите настроить ее на удаленную ветку, которую вы только получили, или хотите изменить upstream-ветку, которую вы отслеживаете, вы можете воспользоваться ключами <code>-u</code> или <code>--set-upstream-to</code> с командой <code>git branch</code>, чтобы явно установить ее в любое время.</p>

<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.</code></pre>

<table>
<tbody><tr>
<td class="icon">

</td>
<td class="content">

<p>Если у вас есть установленная отслеживаемая ветка, вы можете ссылаться на нее с помощью <code>@{upstream}</code> или <code>@{u}</code> сокращенно. Итак, если вы находитесь на <code>master</code>-ветке, а отслеживается <code>origin/master</code>, вы можете вызвать что-то вроде <code>git merge @{u}</code> вместо <code>git merge origin/master</code> если хотите.</p>

</td>
</tr>
</tbody></table>

<p>Если вы хотите посмотреть какие отслеживаемые ветки у вас установлены, вы можете воспользоваться опцией <code>-vv</code> в команде <code>git branch</code>. Отобразится список ваших локальных веток с дополнительной информацией, включая то, какая из веток отслеживается, и если локальная ветка опережает, отстает или равняется относительно основной ветки.</p>

<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new</code></pre>

<p>Итак, здесь мы можем видеть, что наша <code>iss53</code>-ветка отслеживает <code>origin/iss53</code> и она опережает на два изменения, означающее, что мы имеем два локальных коммита, которые не отправлены на сервер. Мы может также увидеть, что наша <code>master</code>-ветка отслеживает <code>origin/master</code> и она в актуальном состоянии. Далее мы можем видеть, что наша <code>serverfix</code>-ветка отслеживает <code>server-fix-good</code>-ветку на нашем <code>teamone</code>-сервере и опережает на три коммита и отстает на один, означающее, что есть один коммит на сервере, который мы еще не слили и три локальных коммита, которые вы еще не отправили. В конце мы видим, что наша <code>testing</code>-ветка не отслеживает удаленную ветку.</p>

<p>Важно отметить, что эти цифры — только с каждого сервера, которые последний раз были извлечены. Эта команда не обращается к серверам, она говорит вам о том, что в кэше есть локальная информация с серверов. Если вы хотите полностью быть в курсе опережающих и отстающих коммитов, вам необходимо извлечь данные из всех ваших удаленных серверов перед запуском этой команды. Вы можете сделать нечто подобное: <code>$ git fetch --all; git branch -vv</code></p>

<h3 id="_получение_изменений">Получение изменений</h3>

<p>
Команда <code>git fetch</code> загрузит с сервера все изменения, которых у вас еще нет, но пока не будет изменять вашу рабочую директорию.
Эта команда просто получает данные для вас и позволяет вам самостоятельно сделать слияние.
Тем не менее, существует команда под названием <code>git pull</code>, которая является по существу командой <code>git fetch</code>, непосредственно за которой следует команда <code>git merge</code>, в большинстве случаев.
Если у вас есть отслеживаемая ветка как показано в предыдущем разделе, либо она явно установлена или она содержится вследствие создания вами командами <code>clone</code> или <code>checkout</code>, <code>git pull</code> увидит, что сервер и ветка вашей текущей ветки отслеживается, извлечет с сервера и затем попытается объединить в удаленную ветку.</p>

<p>Обычно лучше просто явно использовать команды <code>fetch</code> и <code>merge</code>, поскольку магия <code>git pull</code> может часто сбивать с толку.</p>

<h3 id="r_delete_branches">Удаление веток на удалённом сервере</h3>
<div class="paragraph" wfd-id="12">
<p>
Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку <code>master</code> на удалённом сервере (или в какую-то другую ветку, где хранится стабильный код).
Вы можете удалить ветку на удалённом сервере, используя опцию <code>--delete</code> для <code>git push</code>.
Если вы хотите удалить ветку <code>serverfix</code> на сервере, выполните следующее:</p>

<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix</code></pre>

<p>В основном всё, что делает эта строка, — удаляет указатель на сервере. Как правило, Git-сервер оставит данные на некоторое время, пока не запустится сборщик мусора. Итак, если ветка случайно была удалена, чаще всего ее легко восстановить.</p>

</div>
</BODY></HTML>
