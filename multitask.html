<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<TITLE>Многозадачность</TITLE>
<meta name="KeyWords" content="git">
</HEAD>
<BODY BGCOLOR="#DDE1C2" TEXT="#002040">

<div style="width:85%;  margin: auto;">


<p>
<i>Многозадачность (multitask)</i> – способность компьютера выполнять параллельно (или псевдо-параллельно) две программы или два участка кода одной программы.
</p>
<p>
Современные операционные системы имеют встроенную в них поддержку многозадачности.
</p>
<p>
Однако многозадачность может быть реализована на уровне пользовательской программы в однозадачной ОС.
</p>
<p>
Например существовали языки программирования Modula-2 и Ada, которые поддерживали многозадачность вне привязки к какой-либо операционной системе. В результате, популярная в первой половине 1990-х годов реализация языка программирования TopSpeed Модула-2 от JPI/Clarion позволяла организовывать различные типы многозадачности (кооперативную и вытесняющую) для потоков одной программы в рамках такой принципиально однозадачной операционной системы, как MS-DOS. Это осуществлялось путём включения в модуль программы компактного планировщика задач, содержащего обработчик таймерных прерываний.
</p>
<p>
Дальше будем рассматривать только многозадачность реализованную на уровне ОС.
</p>
<p>
По типу наименьшего элемента управляемого кода многозадачность делится на <i>процессную</i> и <i>потоковую</i>.
</p>

<h4>Процессная многозадачность</h4>

<p>Здесь наименьшим элемент управляемого кода, которым может управлять планировщик операционной системы является процесс. Многозадачная система позволяет двум или более программам выполняться одновременно. Например одновременная работа в текстовом редакторе и прослушивание музыки.
</p>
<p>
<i>Процесс</i> — это понятие, относящееся к операционной системе.
Каждый раз при запуске приложения создается и запускается новый процесс.
С каждым процессом связаны следующие ресурсы, как:

<ul>
<li>виртуальное адресное пространство;</li>
<li>исполнимый код и данные;</li>
<li>базовый приоритет;</li>
<li>описатели объектов;</li>
<li>переменные окружения.</li>
</ul>

Исполняемые коды разных процессов выполняются параллельно.
Исполняемый код, связанный с процессом, может выполняться как один поток или как несколько потоков выполняющихся одновременно.
</p>

<h4>Поточная многозадачность</h4>

<p>
<i>Многопоточность</i> — специализированная форма многозадачности.
Наименьшим элементом управляемого кода является <i>поток</i>.
Многопотоковая (multi-threaded) система предоставляет возможность одновременного выполнения одной программой двух и более задач (потоков).
<i>Поток</i> (thread) — это основной элемент системы, которому ОС выделяет машинное время.
Поток может выполнять какую-то часть общего кода процесса, в том числе и ту часть, которая в это время уже выполняется другим потоком.
</p>
<p>Потоки и процессы:
<ul>
<li>Поток определяет последовательность исполнения кода в процессе.</li>
<li>Процесс ничего не исполняет, он просто служит контейнером потоков.</li>
<li>Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах.</li>
<li>Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах.</li>
<li>Т.к. потоки расходуют существенно меньше ресурсов, чем процессы, следует решать свои задачи за счет использования дополнительных потоков и избегать создания новых процессов.</li>
</ul>
</p>
<p>
По способу организации времени выполнения каждого процесса многозадачность бывает:
<ul>
	<li>Параллельная многозадачность</li>
	<li>Псевдопараллельная многозадачность</li>
	<ul>
		<li>Невытесняющая многозадачность</li>
		<li>Совместная или кооперативная многозадачность</li>
		<li>Вытесняющая, или приоритетная, многозадачность (режим реального времени)</li>
	</ul>
</ul>




<h3>Состояние задачи</h3>

<p>Для понимания диспетчеризации важным является понятие состояния задачи. Основные состояния задач такие:
<ul>
<li>выполняется;</li>
<li>готова к исполнению;</li>
<li>заблокирована.</li>
</ul>
</p>

<p>
Задача находится в <i>состоянии исполнения</i> тогда, когда под неё выделен ресурс процессора и передано управление.
Очевидно, что в системе не может быть выполняющихся задач больше, чем физических процессоров.
Поэтому существует второе состояние — <i>готовность к исполнению</i>.
Задача в это состояние тогда, когда она может исполняться, то есть не существует причин, вызывающих блокировку, но вычислительные ресурсы отданы под другие задачи.
В третье состояние задача попадает при невозможности её исполнения в данный момент времени. 
<ul>
<li>ожидание какого либо события</li>
<li>незавершённая инициализация (когда ещё не созданы другой задачей или системой начальные условия для запуска);</li>
<li>«заморозка» (явная остановка исполнения, обычно в отладочных целях);</li>
<li>завершение (состояние , когда исполнение уже закончено, но ресурсы ещё не освобождены);</li>
<li>специфические случаи.</li></ul>
</p>

<p>
В отличие от первых двух, состояние блокировки, вообще говоря не является обязательным. 
</p>

******************************

<h2>Отличия между моделями процессов/потоков в windows и linux <a href="http://citforum.ru/programming/unix/threads/">(citforum.ru)</a></h2>

<p>
В среде <strong>Microsoft Windows процесс, – это контейнер для потоков </strong>(именно этими словами о процессах говорит Джефри Рихтер в своей классической книге «Программирование приложений для Microsoft Windows»). <strong>Процесс-контейнер содержит как минимум один поток.</strong> Если потоков в процессе несколько, приложение (процесс) становится многопоточным.
</p><p>
В мире Linux все выглядит иначе. <strong>В Linux каждый поток является процессом</strong>, и для того, <em>чтобы создать новый поток, нужно создать новый процесс.</em> В чем же, в таком случае, заключается преимущество многопоточности Linux перед многопроцессностью? В многопоточных приложениях Linux <strong>для создания дополнительных потоков используются процессы особого типа</strong>.
</p><p>
Эти процессы представляют собой обычные дочерние процессы главного процесса, но о<strong>ни разделяют с главным процессом </strong>
<strong>
<ol>
<li><strong>адресное пространство</strong></li>
<li>файловые дескрипторы</li>
<li> обработчики сигналов</li>
</ol>
</strong>
</p><p>
Для обозначения процессов этого типа, применяется специальный термин – <strong>легкие процессы (lightweight processes)</strong>.</p><p>
Прилагательное «легкий» в названии процессов- потоков вполне оправдано. Поскольку <strong>этим процессам не нужно создавать собственную копию адресного пространства (и других ресурсов) своего процесса- родителя,</strong> создание нового легкого процесса требует значительно меньших затрат, чем создание полновесного дочернего процесса.
Поскольку потоки Linux на самом деле представляют собой процессы, в мире Linux нельзя говорить, что один процесс содержит несколько потоков.
Если вы скажете это, в вас тут же заподозрят вражеского лазутчика! 
</p>


**************

<h3>Реализация потоков в Linux (<a href="https://it.wikireading.ru/34236"> см.</a>)</h3>

<p>
Потоковые функции, соответствующие стандарту POSIX, реализованы в Linux не так, как в большинстве других версий UNIX.
Суть в том, что в Linux потоки реализованы в виде процессов.
Когда вызывается функция <code class="code">pthread_create()</code>, операционная система на самом деле создает новый процесс, выполняющий поток.
Но это не тот процесс, который создается функцией <code class="code">fork()</code>.
Он, в частности, делит общее адресное пространство и ресурсы с исходным процессом, а не получает их копии.
</p>


</div>
</BODY></HTML>
